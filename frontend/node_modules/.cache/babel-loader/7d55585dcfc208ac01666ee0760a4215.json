{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Template = require(\"./Template\");\n\n/** @typedef {import(\"./Module\")} Module */\n\nmodule.exports = class RuntimeTemplate {\n  constructor(outputOptions, requestShortener) {\n    this.outputOptions = outputOptions || {};\n    this.requestShortener = requestShortener;\n  }\n\n  /**\n   * Add a comment\n   * @param {object} options Information content of the comment\n   * @param {string=} options.request request string used originally\n   * @param {string=} options.chunkName name of the chunk referenced\n   * @param {string=} options.chunkReason reason information of the chunk\n   * @param {string=} options.message additional message\n   * @param {string=} options.exportName name of the export\n   * @returns {string} comment\n   */\n  comment({\n    request,\n    chunkName,\n    chunkReason,\n    message,\n    exportName\n  }) {\n    let content;\n    if (this.outputOptions.pathinfo) {\n      content = [message, request, chunkName, chunkReason].filter(Boolean).map(item => this.requestShortener.shorten(item)).join(\" | \");\n    } else {\n      content = [message, chunkName, chunkReason].filter(Boolean).map(item => this.requestShortener.shorten(item)).join(\" | \");\n    }\n    if (!content) return \"\";\n    if (this.outputOptions.pathinfo) {\n      return Template.toComment(content) + \" \";\n    } else {\n      return Template.toNormalComment(content) + \" \";\n    }\n  }\n  throwMissingModuleErrorFunction({\n    request\n  }) {\n    const err = `Cannot find module '${request}'`;\n    return `function webpackMissingModule() { var e = new Error(${JSON.stringify(err)}); e.code = 'MODULE_NOT_FOUND'; throw e; }`;\n  }\n  missingModule({\n    request\n  }) {\n    return `!(${this.throwMissingModuleErrorFunction({\n      request\n    })}())`;\n  }\n  missingModuleStatement({\n    request\n  }) {\n    return `${this.missingModule({\n      request\n    })};\\n`;\n  }\n  missingModulePromise({\n    request\n  }) {\n    return `Promise.resolve().then(${this.throwMissingModuleErrorFunction({\n      request\n    })})`;\n  }\n  moduleId({\n    module,\n    request\n  }) {\n    if (!module) {\n      return this.missingModule({\n        request\n      });\n    }\n    if (module.id === null) {\n      throw new Error(`RuntimeTemplate.moduleId(): Module ${module.identifier()} has no id. This should not happen.`);\n    }\n    return `${this.comment({\n      request\n    })}${JSON.stringify(module.id)}`;\n  }\n  moduleRaw({\n    module,\n    request\n  }) {\n    if (!module) {\n      return this.missingModule({\n        request\n      });\n    }\n    return `__webpack_require__(${this.moduleId({\n      module,\n      request\n    })})`;\n  }\n  moduleExports({\n    module,\n    request\n  }) {\n    return this.moduleRaw({\n      module,\n      request\n    });\n  }\n  moduleNamespace({\n    module,\n    request,\n    strict\n  }) {\n    if (!module) {\n      return this.missingModule({\n        request\n      });\n    }\n    const moduleId = this.moduleId({\n      module,\n      request\n    });\n    const exportsType = module.buildMeta && module.buildMeta.exportsType;\n    if (exportsType === \"namespace\") {\n      const rawModule = this.moduleRaw({\n        module,\n        request\n      });\n      return rawModule;\n    } else if (exportsType === \"named\") {\n      return `__webpack_require__.t(${moduleId}, 3)`;\n    } else if (strict) {\n      return `__webpack_require__.t(${moduleId}, 1)`;\n    } else {\n      return `__webpack_require__.t(${moduleId}, 7)`;\n    }\n  }\n  moduleNamespacePromise({\n    block,\n    module,\n    request,\n    message,\n    strict,\n    weak\n  }) {\n    if (!module) {\n      return this.missingModulePromise({\n        request\n      });\n    }\n    if (module.id === null) {\n      throw new Error(`RuntimeTemplate.moduleNamespacePromise(): Module ${module.identifier()} has no id. This should not happen.`);\n    }\n    const promise = this.blockPromise({\n      block,\n      message\n    });\n    let getModuleFunction;\n    let idExpr = JSON.stringify(module.id);\n    const comment = this.comment({\n      request\n    });\n    let header = \"\";\n    if (weak) {\n      if (idExpr.length > 8) {\n        // 'var x=\"nnnnnn\";x,\"+x+\",x' vs '\"nnnnnn\",nnnnnn,\"nnnnnn\"'\n        header += `var id = ${idExpr}; `;\n        idExpr = \"id\";\n      }\n      header += `if(!__webpack_require__.m[${idExpr}]) { var e = new Error(\"Module '\" + ${idExpr} + \"' is not available (weak dependency)\"); e.code = 'MODULE_NOT_FOUND'; throw e; } `;\n    }\n    const moduleId = this.moduleId({\n      module,\n      request\n    });\n    const exportsType = module.buildMeta && module.buildMeta.exportsType;\n    if (exportsType === \"namespace\") {\n      if (header) {\n        const rawModule = this.moduleRaw({\n          module,\n          request\n        });\n        getModuleFunction = `function() { ${header}return ${rawModule}; }`;\n      } else {\n        getModuleFunction = `__webpack_require__.bind(null, ${comment}${idExpr})`;\n      }\n    } else if (exportsType === \"named\") {\n      if (header) {\n        getModuleFunction = `function() { ${header}return __webpack_require__.t(${moduleId}, 3); }`;\n      } else {\n        getModuleFunction = `__webpack_require__.t.bind(null, ${comment}${idExpr}, 3)`;\n      }\n    } else if (strict) {\n      if (header) {\n        getModuleFunction = `function() { ${header}return __webpack_require__.t(${moduleId}, 1); }`;\n      } else {\n        getModuleFunction = `__webpack_require__.t.bind(null, ${comment}${idExpr}, 1)`;\n      }\n    } else {\n      if (header) {\n        getModuleFunction = `function() { ${header}return __webpack_require__.t(${moduleId}, 7); }`;\n      } else {\n        getModuleFunction = `__webpack_require__.t.bind(null, ${comment}${idExpr}, 7)`;\n      }\n    }\n    return `${promise || \"Promise.resolve()\"}.then(${getModuleFunction})`;\n  }\n\n  /**\n   *\n   * @param {Object} options options object\n   * @param {boolean=} options.update whether a new variable should be created or the existing one updated\n   * @param {Module} options.module the module\n   * @param {string} options.request the request that should be printed as comment\n   * @param {string} options.importVar name of the import variable\n   * @param {Module} options.originModule module in which the statement is emitted\n   * @returns {string} the import statement\n   */\n  importStatement({\n    update,\n    module,\n    request,\n    importVar,\n    originModule\n  }) {\n    if (!module) {\n      return this.missingModuleStatement({\n        request\n      });\n    }\n    const moduleId = this.moduleId({\n      module,\n      request\n    });\n    const optDeclaration = update ? \"\" : \"var \";\n    const exportsType = module.buildMeta && module.buildMeta.exportsType;\n    let content = `/* harmony import */ ${optDeclaration}${importVar} = __webpack_require__(${moduleId});\\n`;\n    if (!exportsType && !originModule.buildMeta.strictHarmonyModule) {\n      content += `/* harmony import */ ${optDeclaration}${importVar}_default = /*#__PURE__*/__webpack_require__.n(${importVar});\\n`;\n    }\n    if (exportsType === \"named\") {\n      if (Array.isArray(module.buildMeta.providedExports)) {\n        content += `${optDeclaration}${importVar}_namespace = /*#__PURE__*/__webpack_require__.t(${moduleId}, 1);\\n`;\n      } else {\n        content += `${optDeclaration}${importVar}_namespace = /*#__PURE__*/__webpack_require__.t(${moduleId});\\n`;\n      }\n    }\n    return content;\n  }\n  exportFromImport({\n    module,\n    request,\n    exportName,\n    originModule,\n    asiSafe,\n    isCall,\n    callContext,\n    importVar\n  }) {\n    if (!module) {\n      return this.missingModule({\n        request\n      });\n    }\n    const exportsType = module.buildMeta && module.buildMeta.exportsType;\n    if (!exportsType) {\n      if (exportName === \"default\") {\n        if (!originModule.buildMeta.strictHarmonyModule) {\n          if (isCall) {\n            return `${importVar}_default()`;\n          } else if (asiSafe) {\n            return `(${importVar}_default())`;\n          } else {\n            return `${importVar}_default.a`;\n          }\n        } else {\n          return importVar;\n        }\n      } else if (originModule.buildMeta.strictHarmonyModule) {\n        if (exportName) {\n          return \"/* non-default import from non-esm module */undefined\";\n        } else {\n          return `/*#__PURE__*/__webpack_require__.t(${importVar})`;\n        }\n      }\n    }\n    if (exportsType === \"named\") {\n      if (exportName === \"default\") {\n        return importVar;\n      } else if (!exportName) {\n        return `${importVar}_namespace`;\n      }\n    }\n    if (exportName) {\n      const used = module.isUsed(exportName);\n      if (!used) {\n        const comment = Template.toNormalComment(`unused export ${exportName}`);\n        return `${comment} undefined`;\n      }\n      const comment = used !== exportName ? Template.toNormalComment(exportName) + \" \" : \"\";\n      const access = `${importVar}[${comment}${JSON.stringify(used)}]`;\n      if (isCall) {\n        if (callContext === false && asiSafe) {\n          return `(0,${access})`;\n        } else if (callContext === false) {\n          return `Object(${access})`;\n        }\n      }\n      return access;\n    } else {\n      return importVar;\n    }\n  }\n  blockPromise({\n    block,\n    message\n  }) {\n    if (!block || !block.chunkGroup || block.chunkGroup.chunks.length === 0) {\n      const comment = this.comment({\n        message\n      });\n      return `Promise.resolve(${comment.trim()})`;\n    }\n    const chunks = block.chunkGroup.chunks.filter(chunk => !chunk.hasRuntime() && chunk.id !== null);\n    const comment = this.comment({\n      message,\n      chunkName: block.chunkName,\n      chunkReason: block.chunkReason\n    });\n    if (chunks.length === 1) {\n      const chunkId = JSON.stringify(chunks[0].id);\n      return `__webpack_require__.e(${comment}${chunkId})`;\n    } else if (chunks.length > 0) {\n      const requireChunkId = chunk => `__webpack_require__.e(${JSON.stringify(chunk.id)})`;\n      return `Promise.all(${comment.trim()}[${chunks.map(requireChunkId).join(\", \")}])`;\n    } else {\n      return `Promise.resolve(${comment.trim()})`;\n    }\n  }\n  onError() {\n    return \"__webpack_require__.oe\";\n  }\n  defineEsModuleFlagStatement({\n    exportsArgument\n  }) {\n    return `__webpack_require__.r(${exportsArgument});\\n`;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}