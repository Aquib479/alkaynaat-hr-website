{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _sourceMap = require(\"source-map\");\nvar _webpackSources = require(\"webpack-sources\");\nvar _RequestShortener = _interopRequireDefault(require(\"webpack/lib/RequestShortener\"));\nvar _ModuleFilenameHelpers = _interopRequireDefault(require(\"webpack/lib/ModuleFilenameHelpers\"));\nvar _schemaUtils = _interopRequireDefault(require(\"schema-utils\"));\nvar _serializeJavascript = _interopRequireDefault(require(\"serialize-javascript\"));\nvar _package = _interopRequireDefault(require(\"terser/package.json\"));\nvar _options = _interopRequireDefault(require(\"./options.json\"));\nvar _TaskRunner = _interopRequireDefault(require(\"./TaskRunner\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nconst warningRegex = /\\[.+:([0-9]+),([0-9]+)\\]/;\nclass TerserPlugin {\n  constructor(options = {}) {\n    (0, _schemaUtils.default)(_options.default, options, 'Terser Plugin');\n    const {\n      minify,\n      terserOptions = {},\n      test = /\\.m?js(\\?.*)?$/i,\n      chunkFilter = () => true,\n      warningsFilter = () => true,\n      extractComments = false,\n      sourceMap = false,\n      cache = false,\n      cacheKeys = defaultCacheKeys => defaultCacheKeys,\n      parallel = false,\n      include,\n      exclude\n    } = options;\n    this.options = {\n      test,\n      chunkFilter,\n      warningsFilter,\n      extractComments,\n      sourceMap,\n      cache,\n      cacheKeys,\n      parallel,\n      include,\n      exclude,\n      minify,\n      terserOptions: _objectSpread({\n        output: {\n          comments: extractComments ? false : /^\\**!|@preserve|@license|@cc_on/i\n        }\n      }, terserOptions)\n    };\n  }\n  static isSourceMap(input) {\n    // All required options for `new SourceMapConsumer(...options)`\n    // https://github.com/mozilla/source-map#new-sourcemapconsumerrawsourcemap\n    return Boolean(input && input.version && input.sources && Array.isArray(input.sources) && typeof input.mappings === 'string');\n  }\n  static buildSourceMap(inputSourceMap) {\n    if (!inputSourceMap || !TerserPlugin.isSourceMap(inputSourceMap)) {\n      return null;\n    }\n    return new _sourceMap.SourceMapConsumer(inputSourceMap);\n  }\n  static buildError(err, file, sourceMap, requestShortener) {\n    // Handling error which should have line, col, filename and message\n    if (err.line) {\n      const original = sourceMap && sourceMap.originalPositionFor({\n        line: err.line,\n        column: err.col\n      });\n      if (original && original.source && requestShortener) {\n        return new Error(`${file} from Terser\\n${err.message} [${requestShortener.shorten(original.source)}:${original.line},${original.column}][${file}:${err.line},${err.col}]`);\n      }\n      return new Error(`${file} from Terser\\n${err.message} [${file}:${err.line},${err.col}]`);\n    } else if (err.stack) {\n      return new Error(`${file} from Terser\\n${err.stack}`);\n    }\n    return new Error(`${file} from Terser\\n${err.message}`);\n  }\n  static buildWarning(warning, file, sourceMap, requestShortener, warningsFilter) {\n    let warningMessage = warning;\n    let locationMessage = '';\n    let source = null;\n    if (sourceMap) {\n      const match = warningRegex.exec(warning);\n      if (match) {\n        const line = +match[1];\n        const column = +match[2];\n        const original = sourceMap.originalPositionFor({\n          line,\n          column\n        });\n        if (original && original.source && original.source !== file && requestShortener) {\n          ({\n            source\n          } = original);\n          warningMessage = `${warningMessage.replace(warningRegex, '')}`;\n          locationMessage = `[${requestShortener.shorten(original.source)}:${original.line},${original.column}]`;\n        }\n      }\n    }\n    if (warningsFilter && !warningsFilter(warning, source)) {\n      return null;\n    }\n    return `Terser Plugin: ${warningMessage}${locationMessage}`;\n  }\n  apply(compiler) {\n    const buildModuleFn = moduleArg => {\n      // to get detailed location info about errors\n      moduleArg.useSourceMap = true;\n    };\n    const optimizeFn = (compilation, chunks, callback) => {\n      const taskRunner = new _TaskRunner.default({\n        cache: this.options.cache,\n        parallel: this.options.parallel\n      });\n      const processedAssets = new WeakSet();\n      const tasks = [];\n      const {\n        chunkFilter\n      } = this.options;\n      Array.from(chunks).filter(chunk => chunkFilter && chunkFilter(chunk)).reduce((acc, chunk) => acc.concat(chunk.files || []), []).concat(compilation.additionalChunkAssets || []).filter(_ModuleFilenameHelpers.default.matchObject.bind(null, this.options)).forEach(file => {\n        let inputSourceMap;\n        const asset = compilation.assets[file];\n        if (processedAssets.has(asset)) {\n          return;\n        }\n        try {\n          let input;\n          if (this.options.sourceMap && asset.sourceAndMap) {\n            const {\n              source,\n              map\n            } = asset.sourceAndMap();\n            input = source;\n            if (TerserPlugin.isSourceMap(map)) {\n              inputSourceMap = map;\n            } else {\n              inputSourceMap = map;\n              compilation.warnings.push(new Error(`${file} contains invalid source map`));\n            }\n          } else {\n            input = asset.source();\n            inputSourceMap = null;\n          } // Handling comment extraction\n\n          let commentsFile = false;\n          if (this.options.extractComments) {\n            commentsFile = this.options.extractComments.filename || `${file}.LICENSE`;\n            if (typeof commentsFile === 'function') {\n              commentsFile = commentsFile(file);\n            }\n          }\n          const task = {\n            file,\n            input,\n            inputSourceMap,\n            commentsFile,\n            extractComments: this.options.extractComments,\n            terserOptions: this.options.terserOptions,\n            minify: this.options.minify\n          };\n          if (this.options.cache) {\n            const defaultCacheKeys = {\n              terser: _package.default.version,\n              node_version: process.version,\n              // eslint-disable-next-line global-require\n              'terser-webpack-plugin': require('../package.json').version,\n              'terser-webpack-plugin-options': this.options,\n              hash: _crypto.default.createHash('md4').update(input).digest('hex')\n            };\n            task.cacheKeys = this.options.cacheKeys(defaultCacheKeys, file);\n          }\n          tasks.push(task);\n        } catch (error) {\n          compilation.errors.push(TerserPlugin.buildError(error, file, TerserPlugin.buildSourceMap(inputSourceMap), new _RequestShortener.default(compiler.context)));\n        }\n      });\n      taskRunner.run(tasks, (tasksError, results) => {\n        if (tasksError) {\n          compilation.errors.push(tasksError);\n          return;\n        }\n        results.forEach((data, index) => {\n          const {\n            file,\n            input,\n            inputSourceMap,\n            commentsFile\n          } = tasks[index];\n          const {\n            error,\n            map,\n            code,\n            warnings\n          } = data;\n          let {\n            extractedComments\n          } = data;\n          let sourceMap = null;\n          if (error || warnings && warnings.length > 0) {\n            sourceMap = TerserPlugin.buildSourceMap(inputSourceMap);\n          } // Handling results\n          // Error case: add errors, and go to next file\n\n          if (error) {\n            compilation.errors.push(TerserPlugin.buildError(error, file, sourceMap, new _RequestShortener.default(compiler.context)));\n            return;\n          }\n          let outputSource;\n          if (map) {\n            outputSource = new _webpackSources.SourceMapSource(code, file, JSON.parse(map), input, inputSourceMap, true);\n          } else {\n            outputSource = new _webpackSources.RawSource(code);\n          } // Write extracted comments to commentsFile\n\n          if (commentsFile && extractedComments && extractedComments.length > 0) {\n            if (commentsFile in compilation.assets) {\n              const commentsFileSource = compilation.assets[commentsFile].source();\n              extractedComments = extractedComments.filter(comment => !commentsFileSource.includes(comment));\n            }\n            if (extractedComments.length > 0) {\n              // Add a banner to the original file\n              if (this.options.extractComments.banner !== false) {\n                let banner = this.options.extractComments.banner || `For license information please see ${_path.default.posix.basename(commentsFile)}`;\n                if (typeof banner === 'function') {\n                  banner = banner(commentsFile);\n                }\n                if (banner) {\n                  outputSource = new _webpackSources.ConcatSource(`/*! ${banner} */\\n`, outputSource);\n                }\n              }\n              const commentsSource = new _webpackSources.RawSource(`${extractedComments.join('\\n\\n')}\\n`);\n              if (commentsFile in compilation.assets) {\n                // commentsFile already exists, append new comments...\n                if (compilation.assets[commentsFile] instanceof _webpackSources.ConcatSource) {\n                  compilation.assets[commentsFile].add('\\n');\n                  compilation.assets[commentsFile].add(commentsSource);\n                } else {\n                  compilation.assets[commentsFile] = new _webpackSources.ConcatSource(compilation.assets[commentsFile], '\\n', commentsSource);\n                }\n              } else {\n                compilation.assets[commentsFile] = commentsSource;\n              }\n            }\n          } // Updating assets\n\n          processedAssets.add(compilation.assets[file] = outputSource); // Handling warnings\n\n          if (warnings && warnings.length > 0) {\n            warnings.forEach(warning => {\n              const builtWarning = TerserPlugin.buildWarning(warning, file, sourceMap, new _RequestShortener.default(compiler.context), this.options.warningsFilter);\n              if (builtWarning) {\n                compilation.warnings.push(builtWarning);\n              }\n            });\n          }\n        });\n        taskRunner.exit();\n        callback();\n      });\n    };\n    const plugin = {\n      name: this.constructor.name\n    };\n    compiler.hooks.compilation.tap(plugin, compilation => {\n      if (this.options.sourceMap) {\n        compilation.hooks.buildModule.tap(plugin, buildModuleFn);\n      }\n      const {\n        mainTemplate,\n        chunkTemplate\n      } = compilation; // Regenerate `contenthash` for minified assets\n\n      for (const template of [mainTemplate, chunkTemplate]) {\n        template.hooks.hashForChunk.tap(plugin, hash => {\n          const data = (0, _serializeJavascript.default)({\n            terser: _package.default.version,\n            terserOptions: this.options.terserOptions\n          });\n          hash.update('TerserPlugin');\n          hash.update(data);\n        });\n      }\n      compilation.hooks.optimizeChunkAssets.tapAsync(plugin, optimizeFn.bind(this, compilation));\n    });\n  }\n}\nvar _default = TerserPlugin;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}