{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nconst {\n  Tapable,\n  HookMap,\n  SyncHook,\n  SyncWaterfallHook\n} = require(\"tapable\");\nconst Factory = require(\"enhanced-resolve\").ResolverFactory;\n\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n\nmodule.exports = class ResolverFactory extends Tapable {\n  constructor() {\n    super();\n    this.hooks = {\n      resolveOptions: new HookMap(() => new SyncWaterfallHook([\"resolveOptions\"])),\n      resolver: new HookMap(() => new SyncHook([\"resolver\", \"resolveOptions\"]))\n    };\n    this._pluginCompat.tap(\"ResolverFactory\", options => {\n      let match;\n      match = /^resolve-options (.+)$/.exec(options.name);\n      if (match) {\n        this.hooks.resolveOptions.tap(match[1], options.fn.name || \"unnamed compat plugin\", options.fn);\n        return true;\n      }\n      match = /^resolver (.+)$/.exec(options.name);\n      if (match) {\n        this.hooks.resolver.tap(match[1], options.fn.name || \"unnamed compat plugin\", options.fn);\n        return true;\n      }\n    });\n    this.cache1 = new WeakMap();\n    this.cache2 = new Map();\n  }\n  get(type, resolveOptions) {\n    const cachedResolver = this.cache1.get(resolveOptions);\n    if (cachedResolver) return cachedResolver();\n    const ident = `${type}|${JSON.stringify(resolveOptions)}`;\n    const resolver = this.cache2.get(ident);\n    if (resolver) return resolver;\n    const newResolver = this._create(type, resolveOptions);\n    this.cache2.set(ident, newResolver);\n    return newResolver;\n  }\n  _create(type, resolveOptions) {\n    const originalResolveOptions = Object.assign({}, resolveOptions);\n    resolveOptions = this.hooks.resolveOptions.for(type).call(resolveOptions);\n    const resolver = Factory.createResolver(resolveOptions);\n    if (!resolver) {\n      throw new Error(\"No resolver created\");\n    }\n    /** @type {Map<Object, Resolver>} */\n    const childCache = new Map();\n    resolver.withOptions = options => {\n      const cacheEntry = childCache.get(options);\n      if (cacheEntry !== undefined) return cacheEntry;\n      const mergedOptions = Object.assign({}, originalResolveOptions, options);\n      const resolver = this.get(type, mergedOptions);\n      childCache.set(options, resolver);\n      return resolver;\n    };\n    this.hooks.resolver.for(type).call(resolver, resolveOptions);\n    return resolver;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}