{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nclass CachePlugin {\n  constructor(cache) {\n    this.cache = cache || {};\n    this.FS_ACCURACY = 2000;\n  }\n  apply(compiler) {\n    if (Array.isArray(compiler.compilers)) {\n      compiler.compilers.forEach((c, idx) => {\n        new CachePlugin(this.cache[idx] = this.cache[idx] || {}).apply(c);\n      });\n    } else {\n      const registerCacheToCompiler = (compiler, cache) => {\n        compiler.hooks.thisCompilation.tap(\"CachePlugin\", compilation => {\n          compilation.cache = cache;\n          compilation.hooks.childCompiler.tap(\"CachePlugin\", (childCompiler, compilerName, compilerIndex) => {\n            if (cache) {\n              let childCache;\n              if (!cache.children) {\n                cache.children = {};\n              }\n              if (!cache.children[compilerName]) {\n                cache.children[compilerName] = [];\n              }\n              if (cache.children[compilerName][compilerIndex]) {\n                childCache = cache.children[compilerName][compilerIndex];\n              } else {\n                cache.children[compilerName].push(childCache = {});\n              }\n              registerCacheToCompiler(childCompiler, childCache);\n            }\n          });\n        });\n      };\n      registerCacheToCompiler(compiler, this.cache);\n      compiler.hooks.watchRun.tap(\"CachePlugin\", () => {\n        this.watching = true;\n      });\n      compiler.hooks.run.tapAsync(\"CachePlugin\", (compiler, callback) => {\n        if (!compiler._lastCompilationFileDependencies) {\n          return callback();\n        }\n        const fs = compiler.inputFileSystem;\n        const fileTs = compiler.fileTimestamps = new Map();\n        asyncLib.forEach(compiler._lastCompilationFileDependencies, (file, callback) => {\n          fs.stat(file, (err, stat) => {\n            if (err) {\n              if (err.code === \"ENOENT\") return callback();\n              return callback(err);\n            }\n            if (stat.mtime) this.applyMtime(+stat.mtime);\n            fileTs.set(file, +stat.mtime || Infinity);\n            callback();\n          });\n        }, err => {\n          if (err) return callback(err);\n          for (const [file, ts] of fileTs) {\n            fileTs.set(file, ts + this.FS_ACCURACY);\n          }\n          callback();\n        });\n      });\n      compiler.hooks.afterCompile.tap(\"CachePlugin\", compilation => {\n        compilation.compiler._lastCompilationFileDependencies = compilation.fileDependencies;\n        compilation.compiler._lastCompilationContextDependencies = compilation.contextDependencies;\n      });\n    }\n  }\n\n  /* istanbul ignore next */\n  applyMtime(mtime) {\n    if (this.FS_ACCURACY > 1 && mtime % 2 !== 0) this.FS_ACCURACY = 1;else if (this.FS_ACCURACY > 10 && mtime % 20 !== 0) this.FS_ACCURACY = 10;else if (this.FS_ACCURACY > 100 && mtime % 200 !== 0) this.FS_ACCURACY = 100;else if (this.FS_ACCURACY > 1000 && mtime % 2000 !== 0) this.FS_ACCURACY = 1000;\n  }\n}\nmodule.exports = CachePlugin;","map":null,"metadata":{},"sourceType":"script"}